SQLite is a server-less, transactional SQL database engine which has been widely deployed in mobile devices. Popular mobile applications such as messenger, email and social network services rely on SQLite
for data management. However, due to inefficienct date organization and coordination between its database engine and the underlying file and storage system,(references), SQLite suffers from poor transactional performance.

Many efforts have been put to optimize SQLite performance. The optimization approaches mainly fall into two aspects: (1) Investigate SQLite IO characteristics of different database workloads and mitigate the journaling over journal problem ~\cite{shen2014journaling}~\cite{jeong2013stack}; (2) Utilize emerging non-volatile memory technology, such as phase change memory, to eliminate small, random updates to device ~\cite{oh2015sqlite}~\cite{kim2016nvwal}. Though various mechanisms have been proposed, they all culminate with limited performance gain. In this work, we for the first time leverage the LSM-tree data structure  to improve SQLite performance.

Key-value database engine, which offers higher efficiency, scalability, and availability, usually works with simple NoSQL schema. To utilize its advantages with SQL schema, Apache Phoenix~\cite{ApachePhoenix} provides an SQL-like interface and translates SQL queries into a series of scans in  a NoSQL database - HBase. Phoenix demonstrates outstanding performance in data cluster environment. However, it cannot be directly adopted by mobile devices as it is designed for scalable and distributed computing environments with large data sets. 

There exist key-value databases on mobile device, such as SnappyDB. However, there  are not widely used in mobile devices for two major issues. First, lacking of the SQLite interface causes semantic mismatch between SQLite and key value databases; thus, they cannot be directly deployed in SQLite-based mobile applications.  Second, current key value databases requires a large memory footprint with an in-memory meta-data management, in which all indexes from each data block will be scanned and put up into memory for upcoming queries. Such meta-data management approach can help reduce storage overhead, but it will result in notable memory occupation. In most of cloud computing environments, that is not an issue. However, limited memory space should be considered in mobile devices ~\cite{lee2003energy}. 

In this paper, we propose a new SQLite-like NoSQL database engine, called SQLiteKV, which adopts the LSM-tree-based data structure but retains the SQLite operation interfaces. To address the semantic mismatch and memory constraint issues, our SQLiteKV consists of two parts: (1) Front-end layer: A SQLite-to-KV compiler and a Slab-Allocation Caching. (2) Back-end layer: An LSM-tree-based key-value storage engine with an effective meta-data management scheme. 

In the front-end, the compiler receives SQL queries and translate them into the corresponding key-value operations. A caching mechanism is designed to alleviate the discrepancy of data organization between SQLite and key-value database. Considering the memory constraints issue in mobile devices, we manage the caching with a slab-based approach to eliminate memory fragmentation \cite{ding2013integrated}. Caching space are firstly segmented into slabs while each slab is further striped into an array of slots with equal size. Slot sizes in different slabs increase exponentially. Query results are buffered into a slab whose slot size is of the best fit with its own size. 

As for the back-end, we deploy a LSM-tree-based key-value database engine which transform random writes to sequential writes by aggregating multiple updates in memory and dumping them to storage in a "batch" manner. To mitigate the memory requirement by our KV engine, our strategy is to store the meta-data of those top levels in memory exclusively and leave others in disk. 

We have implemented and deployed SQLiteKV on a Google Nexus Android platform. The experimental results with various workloads show that our SQLiteKV presents an improvement of 6 times in the operations per second for insert and query operations compared with SQLite, respectively. Our contributions are concluded as follows:

\begin{itemize}
	\item We for the first time propose to improve the performance of SQLite by adopting the LSM-tree-based key-value database engine while remaining the SQLite interfaces for mobile devices.
	\item We design a slab-based coordination caching scheme to solve the semantic mismatch between the SQL interfaces and the key-value database engine, which also effectively improves the system performance.
	\item To mitigate the memory requirement for mobile devices, we have re-designed the index management policy for the LSM-tree-based key-value database engine. 
	\item We have implemented and deployed a prototype of SQLiteKV with a real Google Android platform, and the evaluation results show the effective of our proposed design.
\end{itemize}

The rest of paper is organized as follows. Chapter 2 gives background. Chapter 3 describes the design and implementation. Experimental results are presented in Chapter 4. In Chapter 5, we conclude the paper.
